---
import BaseLayout from '../layouts/BaseLayout.astro';
import MarkdownIt from 'markdown-it';
import { highlightCodeAsync } from '../utils/highlighter';
import { Icon } from 'astro-icon/components';
import Breadcrumbs from '../components/Breadcrumbs.astro';
import { withBasePath } from '../lib/paths';

interface Props {
  release: { slug: string; basePath: string };
  pluginData: { pluginSlots: any[]; mfes: any[] };
  filtersData: { filters: any[] };
  eventsData: { events: any[] };
  slot: any;
  mfe: any;
}

const { release, pluginData, filtersData, eventsData, slot, mfe } = Astro.props as Props;
const basePath = release.basePath;

let readmeHtml = '';
if (slot.readmePresent && slot.readmeContent) {
  readmeHtml = await markdownToHtml(slot.readmeContent, slot.sourceUrl);
}

async function markdownToHtml(markdown: string, sourceUrl: string): Promise<string> {
  const baseImageUrl = sourceUrl.replace('/tree/', '/raw/');

  const md = new MarkdownIt({
    html: false,
    linkify: true,
    breaks: true,
  });

  const defaultImage =
    md.renderer.rules.image ??
    ((tokens, idx, options, env, self) => self.renderToken(tokens, idx, options));
  md.renderer.rules.image = (tokens, idx, options, env, self) => {
    const token = tokens[idx];
    const src = token.attrGet('src');
    if (src && !/^(https?:)?\/\//i.test(src) && !src.startsWith('data:')) {
      const normalized = src.replace(/^\.\//, '').replace(/^\//, '');
      token.attrSet('src', `${baseImageUrl}/${normalized}`);
    }
    token.attrSet('style', 'max-width: 100%; height: auto;');
    return defaultImage(tokens, idx, options, env, self);
  };

  const defaultLinkOpen =
    md.renderer.rules.link_open ??
    ((tokens, idx, options, env, self) => self.renderToken(tokens, idx, options));
  md.renderer.rules.link_open = (tokens, idx, options, env, self) => {
    const token = tokens[idx];
    token.attrSet('target', '_blank');
    token.attrSet('rel', 'noopener noreferrer');
    return defaultLinkOpen(tokens, idx, options, env, self);
  };

  let html = md.render(markdown);

  const codeBlockRegex = /<pre><code class="language-([^"]+)">([^<]*)<\/code><\/pre>/g;
  const parts: (string | Promise<string>)[] = [];
  let lastIndex = 0;
  let blockMatch;

  while ((blockMatch = codeBlockRegex.exec(html)) !== null) {
    parts.push(html.substring(lastIndex, blockMatch.index));
    const lang = blockMatch[1];
    const code = decodeHtml(blockMatch[2]);
    parts.push(highlightCodeAsync(code, lang));
    lastIndex = codeBlockRegex.lastIndex;
  }
  parts.push(html.substring(lastIndex));

  const resolvedParts = await Promise.all(parts);
  return resolvedParts.join('');
}

function decodeHtml(html: string): string {
  const map: Record<string, string> = {
    '&amp;': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&#039;': "'",
  };
  return html.replace(/&amp;|&lt;|&gt;|&quot;|&#039;/g, (m) => map[m]);
}
---

<BaseLayout
  title={slot.id}
  basePath={basePath}
  release={release.slug}
  pluginData={pluginData}
  filtersData={filtersData}
  eventsData={eventsData}
  showSidebar
  currentMfeId={slot.mfeId}
>
  <section class="space-y-4">
    <Breadcrumbs
      items={[
        { label: 'MFEs', href: withBasePath(basePath, '/mfes') },
        { label: slot.mfeName, href: withBasePath(basePath, `/mfes/${slot.mfeId}`) },
        { label: slot.id },
      ]}
    />

    {slot.readmePresent && slot.readmeContent ? (
      <article class="readme-content rounded-box border border-base-300 bg-base-100 p-5 shadow-sm sm:p-7">
        <Fragment set:html={readmeHtml} />
      </article>
    ) : (
      <div class="space-y-3">
        <h1 class="text-4xl font-bold break-all">{slot.id}</h1>
        <div class="alert">
          <Icon name="tabler:file-text" width="1rem" height="1rem" />
          <span>No README documentation available for this plugin slot.</span>
        </div>
        <a href={slot.sourceUrl} target="_blank" rel="noopener noreferrer" class="btn btn-primary btn-sm w-fit">
          View on GitHub
        </a>
      </div>
    )}
  </section>
</BaseLayout>

<style>
  .readme-content :global(h1) {
    margin: 0.25rem 0 1rem 0;
    border-bottom: 1px solid color-mix(in oklab, var(--color-base-content) 15%, transparent);
    padding-bottom: 0.6rem;
    font-size: 1.9rem;
    word-break: break-word;
  }

  .readme-content :global(h2) {
    margin: 1.3rem 0 0.75rem 0;
    border-left: 6px solid var(--color-primary);
    background: color-mix(in oklab, var(--color-primary) 10%, transparent);
    border-radius: 0.45rem;
    padding: 0.5rem 0.8rem;
    font-size: 1.2rem;
    word-break: break-word;
  }

  .readme-content :global(h3) {
    margin: 1rem 0 0.5rem 0;
    border-bottom: 1px solid color-mix(in oklab, var(--color-primary) 45%, transparent);
    padding-bottom: 0.3rem;
    font-size: 1.05rem;
    word-break: break-word;
  }

  .readme-content :global(p) {
    margin: 0.9rem 0;
    line-height: 1.65;
    color: color-mix(in oklab, var(--color-base-content) 86%, transparent);
  }

  .readme-content :global(code) {
    background: var(--color-base-200);
    border-radius: 0.35rem;
    padding: 0.15rem 0.4rem;
    font-size: 0.88rem;
    word-break: break-word;
  }

  .readme-content :global(pre) {
    margin: 1rem 0;
    overflow-x: auto;
    border: 1px solid color-mix(in oklab, var(--color-base-content) 15%, transparent);
    border-radius: 0.5rem;
    padding: 1rem;
    background: var(--color-base-100);
  }

  .readme-content :global(pre code) {
    background: transparent;
    padding: 0;
  }

  .readme-content :global(ul),
  .readme-content :global(ol) {
    margin: 0.9rem 0;
    padding-left: 1.4rem;
  }

  .readme-content :global(li) {
    margin: 0.35rem 0;
    line-height: 1.55;
  }

  .readme-content :global(a) {
    color: var(--color-primary);
    text-decoration: underline;
    text-underline-offset: 2px;
  }
</style>
