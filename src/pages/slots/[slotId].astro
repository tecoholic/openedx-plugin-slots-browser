---
import BaseLayout from '../../layouts/BaseLayout.astro';
import pluginData from '../../data/plugin-slots.json';
import MarkdownIt from 'markdown-it';
import { highlightCodeAsync } from '../../utils/highlighter';
import { Icon } from 'astro-icon/components';

export function getStaticPaths() {
  return pluginData.pluginSlots.map((slot) => ({
    params: { slotId: slot.id },
  }));
}

const { slotId } = Astro.params;
const slot = pluginData.pluginSlots.find((s) => s.id === slotId);
const mfe = pluginData.mfes.find((m) => m.id === slot?.mfeId);

if (!slot || !mfe) {
  return Astro.redirect('/openedx-plugins-browser/');
}

let readmeHtml = '';
if (slot.readmePresent && slot.readmeContent) {
  readmeHtml = await markdownToHtml(slot.readmeContent, slot.sourceUrl);
}

async function markdownToHtml(markdown: string, sourceUrl: string): Promise<string> {
  // Build base URL for images (convert tree to raw for GitHub)
  const baseImageUrl = sourceUrl.replace('/tree/', '/raw/');

  const md = new MarkdownIt({
    html: false,
    linkify: true,
    breaks: true
  });

  const defaultImage =
    md.renderer.rules.image ??
    ((tokens, idx, options, env, self) => self.renderToken(tokens, idx, options));
  md.renderer.rules.image = (tokens, idx, options, env, self) => {
    const token = tokens[idx];
    const src = token.attrGet('src');
    if (src && !/^(https?:)?\/\//i.test(src) && !src.startsWith('data:')) {
      const normalized = src.replace(/^\.\//, '').replace(/^\//, '');
      token.attrSet('src', `${baseImageUrl}/${normalized}`);
    }
    token.attrSet('style', 'max-width: 100%; height: auto;');
    return defaultImage(tokens, idx, options, env, self);
  };

  const defaultLinkOpen =
    md.renderer.rules.link_open ??
    ((tokens, idx, options, env, self) => self.renderToken(tokens, idx, options));
  md.renderer.rules.link_open = (tokens, idx, options, env, self) => {
    const token = tokens[idx];
    token.attrSet('target', '_blank');
    token.attrSet('rel', 'noopener noreferrer');
    return defaultLinkOpen(tokens, idx, options, env, self);
  };

  let html = md.render(markdown);

  // Apply syntax highlighting to code blocks
  const codeBlockRegex = /<pre><code class="language-([^"]+)">([^<]*)<\/code><\/pre>/g;
  const parts: (string | Promise<string>)[] = [];
  let lastIndex = 0;
  let blockMatch;

  while ((blockMatch = codeBlockRegex.exec(html)) !== null) {
    parts.push(html.substring(lastIndex, blockMatch.index));
    const lang = blockMatch[1];
    const code = decodeHtml(blockMatch[2]);
    parts.push(highlightCodeAsync(code, lang));
    lastIndex = codeBlockRegex.lastIndex;
  }
  parts.push(html.substring(lastIndex));

  const resolvedParts = await Promise.all(parts);
  return resolvedParts.join('');
}

function decodeHtml(html: string): string {
  const map: Record<string, string> = {
    '&amp;': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&#039;': "'"
  };
  return html.replace(/&amp;|&lt;|&gt;|&quot;|&#039;/g, (m) => map[m]);
}
---

<BaseLayout title={slot.id} showSidebar currentMfeId={slot.mfeId}>
  <div class="header">
    <div class="breadcrumb">
      <a href={`/openedx-plugin-slots-browser/mfes/${slot.mfeId}`}>{slot.mfeName}</a>
      <span class="separator">/</span>
      <span class="current">{slot.id}</span>
    </div>
  </div>

  <div class="slot-content">
    {slot.readmePresent && slot.readmeContent ? (
      <div class="readme-content">
        <Fragment set:html={readmeHtml} />
      </div>
    ) : (
      <h1>{slot.id}</h1>
      <div class="no-readme">
        <p><Icon name="tabler:file-text" /> No README documentation available for this plugin slot.</p>
        <p>
          <a href={slot.sourceUrl} target="_blank" rel="noopener noreferrer" class="btn btn-small">
            View on GitHub â†’
          </a>
        </p>
      </div>
    )}
  </div>
</BaseLayout>

<style>
  .header {
    margin-bottom: 2rem;
  }

  .breadcrumb {
    font-size: 0.9rem;
    color: #666;
    margin-bottom: 1rem;
  }

  .breadcrumb a {
    color: var(--color-primary);
    text-decoration: none;
  }

  .breadcrumb a:hover {
    text-decoration: underline;
  }

  .separator {
    margin: 0 0.5rem;
  }

  .current {
    font-weight: 500;
  }

  .header h1 {
    margin: 0;
  }

  .slot-content {
    max-width: 100%;
  }

  .readme-content {
    background: white;
  }

  .readme-content :global(h1) {
    margin: 2rem 0 1rem 0;
    border-bottom: 1px solid var(--color-border);
    padding-bottom: 0.5rem;
    word-wrap: break-word;

    @media (max-width: 786px) {
      font-size: 1.5rem;
    }
  }

  .readme-content :global(h2) {
    font-size: 1.25rem;
    margin: 1.5rem 0 0.75rem 0;
    color: var(--color-primary);
    background: #eef4ff;
    border-left: 8px solid var(--color-primary);
    padding: 0.6rem 0.85rem;
    border-radius: 4px;
    word-wrap: break-word;
  }

  .readme-content :global(h3) {
    font-size: 1.1rem;
    margin: 1.25rem 0 0.5rem 0;
    padding: 0.5rem 0.75rem;
    border-bottom: 1px solid var(--color-primary);
    word-wrap: break-word;
  }

  .readme-content :global(p) {
    line-height: 1.6;
    margin: 1rem 0;
    color: #333;
  }

  .readme-content :global(code) {
    background: var(--color-secondary);
    padding: 0.25rem 0.5rem;
    border-radius: 3px;
    font-family: 'Courier New', monospace;
    font-size: 0.9em;
  }

  .readme-content :global(pre) {
    background: #ffffff;
    border: 1px solid #e1e4e8;
    border-left: 4px solid var(--color-primary);
    padding: 1rem;
    border-radius: 4px;
    overflow-x: auto;
    margin: 1rem 0;
  }

  .readme-content :global(pre code) {
    background: none;
    padding: 0;
    color: inherit;
  }

  .readme-content :global(code) {
    white-space: pre-wrap;
  }

  .readme-content :global(ul) {
    margin: 1rem 0;
    padding-left: 2rem;
  }

  .readme-content :global(li) {
    margin: 0.5rem 0;
    line-height: 1.6;
  }

  .readme-content :global(a) {
    color: var(--color-primary);
    text-decoration: underline;
  }

  .readme-content :global(a:hover) {
    text-decoration: none;
  }

  .readme-content :global(img) {
    max-width: 100%;
    height: auto;
    margin: 1rem 0;
    border-radius: 4px;
    border: 1px solid var(--color-border);
  }

  .no-readme {
    background: #fff8f8;
    border: 1px solid #fee;
    border-radius: 8px;
    padding: 2rem;
    text-align: center;
  }

  .no-readme p {
    margin: 0.5rem 0;
    color: #666;
  }

  .no-readme p :global(svg) {
    display: inline;
    vertical-align: -0.125em;
    margin-right: 0.25rem;
    width: 1.1em;
    height: 1.1em;
  }

  .btn-small {
    display: inline-block;
    padding: 0.5rem 1rem;
    background: var(--color-primary);
    color: white;
    text-decoration: none;
    border-radius: 4px;
    font-size: 0.9rem;
  }

  .btn-small:hover {
    background: #0052a3;
  }
</style>
